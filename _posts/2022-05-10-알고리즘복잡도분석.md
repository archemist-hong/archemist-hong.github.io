---
layout: single
title : "알고리즘 복잡도 분석"
author_profile: true
categories: DS
tag: [DS, python] 
toc: true
use_math: true
---



**본 포스트는 아래 서적을 스스로 공부하며 중요하다고 생각하는 부분만 정리한 내용입니다.**

**공부서적: [C언어로 쉽게 풀어쓴 자료구조](https://book.naver.com/bookdb/book_detail.naver?bid=14566230)**



<br>

# 프로그램의 효율성 측정

알고리즘 간의 효율성은 입력자료의 양이 적은 경우에는 무시해도 상관 없지만, 자료의 양이 많아지는 경우에는 중요하다.

프로그램의 효율성은 다음과 같이 측정할 수 있다.



## 1. 실제로 실행시켜 수행시간을 측정

```python
def algorithmA(n): # n * n을 계산하여 리턴
    return n * n

def algorithmB(n): # 1을 n번 더하고, 그것을 n번 더하여 n * n을 계산하여 리턴
    ans = 0
    for i in range(1, n+1):
        for j in range(1, n+1):
            ans += 1
    return ans
```



**알고리즘 A(n*n)**

```python
import time

start = time.time() # 알고리즘의 수행시작시간 기록
print(algorithmA(1000))
end = time.time() # 알고리즘의 수행종료시간 기록

print(f"수행시간 : {end - start:.5f} sec")
```

<pre>
1000000
수행시간 : 0.00000 sec
</pre>



**알고리즘 B(2중 반복문)**

```python
import time

start = time.time() # 알고리즘의 수행시작시간 기록
print(algorithmB(1000))
end = time.time() # 알고리즘의 수행종료시간 기록

print(f"수행시간 : {end - start:.5f} sec")
```

<pre>
1000000
수행시간 : 0.03491 sec
</pre>



그러나 실제로 실행시키는 방법은 알고리즘을 구현하고, 테스트하는 것이 필요하다.

- 알고리즘이 복잡한 경우에는 구현이 부담 될 수 있으며
- 이 방법을 사용하는 경우에는 하드웨어, 프로그래밍 언어와 같은 개발환경이 반드시 동일한 상태에서 비교해야한다.
- 또한, 실험에 사용한 데이터가 아닌 다른 데이터에 대해서는 결과로 얻은 수행시간을 주장할 수 없다.



## 2. 알고리즘 복잡도 분석

알고리즘 복잡도 분석은 구현하지 않고, 알고리즘의 효율성을 따져보는 기법이다.

실제 알고리즘을 구현하지 않고 가능한 모든 입력을 고려하며, 실행 하드웨어, 소프트웨어 환경과 관계없이 효율성을 평가할 수 있다.

알고리즘 복잡도 분석은 크게 2가지로 분류된다.

- 수행시간 분석(시간복잡도) - 절대적인 수행시간 대신 연산의 수행 횟수를 숫자료 표시한다.
- 기억공간 분석(공간복잡도) - 메모리와 같은 리소스 사용량을 다루며, 보통 시간복잡도를 더 많이 사용한다.



일반적으로 연산의 수행 횟수는 고정된 숫자가 아니라, 입력의 개수(\\(n\\))에 대한 함수가 된다.

\\(T(n)\\) : 연산의 수를 입력의 개수 \\(n\\)에 대한 함수로 나타낸 시간 복잡도 함수

입력자료의 개수가 많은 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고, 다른 항들은 상대적으로 무시될 수 있다.

따라서 보통 시간 복잡도 함수에서는 차수가 가장 큰 항만을 고려하면 충분하다.

이렇게 시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 **빅오 표기법** 이라고 한다.



### 빅오 표기법

빅오 표기법을 활용하여, 알고리즘을 비교하는 경우,

"알고리즘A의 시간복잡도가 \\(O(n)\\)이다." 라고 말하며,

\\(O(n)\\): 빅오 of  \\(n\\)이라고 한다.

빅오 표기법 : \\(n\\)의 값에 따른 함수의 **상한값**을 나타내는 방법

다항식의 최고차항만을 남기고, 다른 항들과 상수항을 버리며, 최고차항의 계수도 버리고 차수만을 사용하는 방식으로 빅오 표기법을 간단하게 얻을 수 있다.

EX)

\\(a_mn^m + ... + a_1n + a_0 = O(n^m)\\)

이때, \\(log n\\)은 차수를 가지므로, 계수로서 없애면 안된다.

이렇게 빅오 표기법을 사용하면, 알고리즘의 대략적인 수행시간을 추정해 볼 수 있으며, 알고리즘이 지수형이나 팩토리얼형이면 너무 많은 수행시간을 요구하므로 사실상 사용할 수 없다.

\\(O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!) \\)



빅오 표기법은 상한을 표시한 것인데, 상한은 여러개가 존재할 수 있으므로, 이러한 문제점을 보완하기 위한 빅오메가, 빅세타 표기법이 있다.

- 빅오메가 : 어떤 함수의 하한을 표시하는 방법

  \\(f(n) = 2n + 1, n>1 에 대해 f(n) >= n 이므로, f(n) = \Omega(n) \\)

- 빅세타: 동일한 함수로 상한과 하한을 만들 수 있는 경우

  \\(f(n) = 2n + 1, n>1 에 대해 3n >= f(n) >= n 이므로, f(n) = \Theta(n) \\)

가장 정밀한 것은 빅세타 이지만, 통상적으로 빅오 표기법을 많이 사용한다.



한편, 똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행시간을 보일 수 있다.

1. 최악의 경우 : 알고리즘의 수행시간이 가장 오래 걸리는 경우
2. 최선의 경우 : 수행시간이 가장 적은 경우
3. 평균적인 경우 : 모든 입력을 고려하고, 각 입력이 발생하는 확률을 고려한 평균 수행시간

평균적인 경우가 가장 좋아보이지만, 평균값을 계산하기가 어려우므로 최악의 경우의 수행시간을 시간복잡도의 척도로 많이 사용한다.

또, 어떤 경우에는 최악의 경우가 평균보다 더 중요한 의미를 가지기도 한다.

EX) 비행기 관제업무: 어떤 입력이 주어지더라도 반드시 주어진 시간 내에 계산을 끝마쳐야 한다.
