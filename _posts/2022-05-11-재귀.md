---
layout: single
title : "재귀"
author_profile: true
categories: DS
tag: [DS, python] 
toc: true
use_math: true
---



**본 포스트는 아래 서적을 스스로 공부하며 중요하다고 생각하는 부분만 정리한 내용입니다.**

**공부서적: [C언어로 쉽게 풀어쓴 자료구조](https://book.naver.com/bookdb/book_detail.naver?bid=14566230)**



<br>

# 재귀

재귀 : 어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법

EX) 팩토리얼함수, 피보나치 수열, 이항계수, 이진 트리, 이진 탐색, 하노이탑 등



[팩토리얼](https://ko.wikipedia.org/wiki/%EA%B3%84%EC%8A%B9)함수는 자신을 정의하는데 다시 팩토리얼이 사용된다.

```python
def Fact(n):
    if n <= 1: # n <= 1이면, 1
        return 1
    else:
        return n * Fact(n-1) # n >= 1이면, n * (n-1)!
```



하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일하다.

즉, 복귀주소가 시스템 스택에 저장되고, 호출되는 함수를 위한 매개변수와 지역변수를 스택으로부터 할당받는다.

이러한 함수를 위한 시스템 스택에서의 공간을 활성 레코드라고 하며, 준비가 끝나면 수행을 시작한다.

![recursion](../../images/2022-05-11-재귀/recursion.PNG)

C, JAVA 등 현대적 프로그래밍 언어에서는 재귀를 지원하지만, FORTRAN, COBOL과 같은 고전적 언어는 지역 변수가 없거나 변수가 정적으로 할당되므로 재귀가 불가능하다.

즉, 함수 호출마다 새로운 지역변수를 만들지 못하면, 이전 호출과 구분할 수 없어서 재귀호출이 불가능하다.



## 재귀 알고리즘

재귀 알고리즘은

- 자기자신을 자체적으로 호출하는 부분과
- 재귀호출을 멈추는 부분

으로 구성된다.

만약, 재귀호출을 멈추는 부분이 없다면 시스템 스택을 다 사용할때까지 호출되다가 오류를 발생하며 멈추므로, **반드시 재귀호출에는 재귀를 멈추는 문장이 포함되어야 한다.**

재귀는 문제의 일부를 해결하고, 나머지 문제에 대해 순환호출한다는 것을 의미한다.

이런식으로 주어진 문제를 더 작은 동일한 문제들로 분해해서 해결하는 방법을 분할 정복이라고 한다.

함수 호출을 반복할 수록 문제의 크기는 점점 작아지면서 풀기 쉬워지고, 결국은 아주 풀기쉬운 문제가 된다.



## 재귀와 반복

반복은 for, while 등 반복구조로 되풀이 하는 방법이다.

때로는 반복을 사용하면 문제가 지나치게 복잡해지는 경우가 존재하므로 이런경우에는 재귀를 사용하면 반복에 비해 알고리즘을 훨씬 명확하고, 간결하게 나타내는 좋은 해결책이 될 수 있다.

기본적으로 반복과 재귀는 문제해결 능력이 같으며, 재귀를 반복으로, 반복을 재귀로 바꾸어 쓸 수 있다.

특히, 재귀 호출이 끝에서 이루어지는 꼬리재귀는 반복알고리즘으로 쉽게 바꿔 쓸 수 있다.

반면 머리순환 또는 여러군데에서 자기 자신을 호출하는 함수는 쉽게 반복 코드로 바꾸기 어렵다.

따라서 동일한 알고리즘을 꼬리재귀와 머리재귀 모두로 표현할 수 있다면, 당연히 꼬리재귀로 작성해야 한다.

일반적으로 재귀는 함수호출을 하게 되므로, 반복에 비해 수행 속도면에서는 떨어진다.

따라서 알고리즘을 설명할 때는 재귀로 하고, 실제 프로그램에서는 반복으로 바꾸어 코딩하는 경우도 있다.



### 팩토리얼 함수



**팩토리얼 함수의 반복**

```python
def Fact_iter(n):
    if n <= 0:
        return 1
    else:
        ans = 1
        for i in range(1, n+1):
            ans *= i
        return ans
```

반복알고리즘은 for를 사용하여, 곱셈을 n번 반복하므로, 시간복잡도는 대략 \\(O(n)\\)이다.



**팩토리얼 함수의 재귀 풀이**

```python
def Fact_recur(n):
    if n <= 1:
        return 1
    else:
        return n * Fact_recur(n-1)
```

재귀알고리즘은 한번 호출마다 1번의 곱셈이 n번 호출되므로, 시간복잡도는 대략 \\(O(n)\\)이다.



두 경우 모두 시간 복잡도는 같지만, 재귀는 여분의 함수호출을 위해 여분의 기억공간이 더 필요하며 사전작업이 상당히 필요하므로 시간이 더 걸린다.

재귀함수는

- 이해하기 쉽고, 쉽게 프로그램 할 수 있다.
- 수행시간과 기억공간의 사용에 있어서는 비효율적이다.



### x의 n제곱

\\(x^n\\)을 구하는 문제를 반복으로도 풀이할 수 있지만, \\(x^n = (x^2)^{n / 2}\\)라는 사실을 이용하여 재귀로 해결할 수 있다.



**재귀풀이**

```python
def Power_recur(x, n):
    if n == 0:
        return 1
    elif n % 2 == 0: # n이 짝수이면,
        return Power_recur(x ** 2, n / 2)
    else: # n이 홀수이면,
        return x * Power_recur(x ** 2, (n-1) / 2)
```

```python
import time

start = time.time() # 알고리즘의 수행시작시간 기록
Power_recur(2, 100000)
end = time.time() # 알고리즘의 수행종료시간 기록

print(f"수행시간 : {end - start:.5f} sec")
```

<pre>
    수행시간 : 0.00100 sec
</pre>



\\(2^{10}\\)을 구하는 문제라면, power_recur(2, 10) -> power_recur(4, 5) -> power_recur(16, 2) -> power_recur(256, 1) -> power_recur(65536, 0)순으로 문제가 해결된다.

n이 2의 거듭제곱인 \\(2^k\\)라고 가정하면, 재귀호출을 할때마다 n이 절반씩 줄어들기 때문에 함수를 k번 호출하여 문제를 해결하게 된다.

\\(logn = k\\)이고, 한번 호출에 약 한번의 곱셈과 나눗셈이 일어나므로 전체 연산수는 k에 비례하고, 시간복잡도는 \\(O(logn)\\)이다.



**반복 풀이**

```python
def Power_iter(x, n):
    if n == 0:
        return 1
    else:
        ans = 1
        for i in range(n):
            ans *= x
        return ans
```

```python
import time

start = time.time() # 알고리즘의 수행시작시간 기록
Power_iter(2, 100000)
end = time.time() # 알고리즘의 수행종료시간 기록

print(f"수행시간 : {end - start:.5f} sec")
```

<pre>
    수행시간 : 0.14163 sec
</pre>



반복의 경우 한번루프에 한번의 곱셈이 필요하므로 시간복잡도는 \\(O(n)\\)이 된다.

이경우, 재귀를 이용한 문제 해결이 반복보다 빠르다.



###  피보나치 수열

재귀를 사용하면, 단순하게 작성하여 가독성이 좋아지지만 똑같은 계산을 몇번씩 반복하면, 단순한경우에도 계산시간이 길어질 수 있다.

[피보나치 수열](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98)

피보나치 수열은 앞의 두개의 숫자를 더해서 뒤의 숫자를 만든다.

```python
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2) # 재귀 호출
```

```python
import time

start = time.time() # 알고리즘의 수행시작시간 기록
fib(20)
end = time.time() # 알고리즘의 수행종료시간 기록

print(f"수행시간 : {end - start:.5f} sec")
```

<pre>
    수행시간 : 0.00199 sec
</pre>



재귀를 사용하여, fib 함수를 작성하는 경우, fib(6)을 호출하는 경우에는 fib(4)가 2번 계산되며, fib(3)은 3번 계산된다.

이러한 현상은 재귀호출이 깊어질수록 더 심해지므로 상당히 비효율적이다.

근본적인 이유는 중간에 계산되었던 값을 기억하지 않고, 다시 계산을 하기 때문이며, n이 커지면 재귀로 피보나치 수열을 계산하는 것은 거의 불가능하다.

![fibonacci](../../images/2022-05-11-재귀/fibonacci.PNG)



이 경우, 재귀를 사용하지 않고 반복을 사용하면, 약 \\(O(n)\\)으로 해결할 수 있다.

```python
def fib_iter(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        ans = 0 # fib(n)으로 누적할 곳
        pp = 0 # fib(n-2)
        p = 1 # fib(n-1)
        for i in range(2, n+1):
            ans = p + pp # fib(n) = fib(n-1) + fib(n-2)
            pp = p # fib(n-2)에 fib(n-1) 대입
            p = ans #fig(n-1)에 fib(n) 대입
        return ans
```

```python
import time

start = time.time() # 알고리즘의 수행시작시간 기록
fib_iter(20)
end = time.time() # 알고리즘의 수행종료시간 기록

print(f"수행시간 : {end - start:.5f} sec")
```

<pre>
    수행시간 : 0.00000 sec
</pre>



### 하노이탑

[하노이의 탑](https://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91)

이 문제는 재귀로 생각하면 쉽게 해결할 수 있다.

n개의 원판이 A에 쌓여있는 경우, 먼저 위에 쌓여있는 n-1개의 원판을 B로 옮긴다음 제일 밑에 있는 원판을 C로 옮긴다.

이어서 B에 있던 n-1개 원판을 C로 옮긴다.

이제 문제는 B에 쌓은 n-1개 원판을 어떻게 C로 옮기느냐 이다.

![hanoi](../../images/2022-05-11-재귀/hanoi.PNG)

```python
def hanoi(n, A, C, B):
    if n == 1:
        print(f"원판 {n}을 {A}에서 {C}로 옮긴다.")
    else:
        hanoi(n-1, A, B, C) # n-1개 원판을 A에서 B로 옮긴다.
        print(f"원판 {n}을 {A}에서 {C}로 옮긴다.")
        hanoi(n-1, B, C, A) # n-1개 원판을 B에서 C로 옮긴다.
```

```python
hanoi(3, 'A', 'C', 'B')
```

<pre>
원판 1을 A에서 C로 옮긴다.
원판 2을 A에서 B로 옮긴다.
원판 1을 C에서 B로 옮긴다.
원판 3을 A에서 C로 옮긴다.
원판 1을 B에서 A로 옮긴다.
원판 2을 B에서 C로 옮긴다.
원판 1을 A에서 C로 옮긴다.
</pre>



이처럼 재귀를 사용하면, 복잡해 보이는 문제도 쉽게 해결 할 수 있다.

